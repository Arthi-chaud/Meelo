import { ResourceNotFound } from "@/models/exceptions";
import { AppName, UserAccessTokenStorageKey } from "@/utils/constants";
import {
	HydrationBoundary as Hydrate,
	QueryClient,
	QueryClientProvider,
	dehydrate,
} from "@tanstack/react-query";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";
import { ConfirmProvider } from "material-ui-confirm";
import NextApp, { type AppContext, type AppProps } from "next/app";
import Head from "next/head";
import { useRouter } from "next/router";
import { useEffect, useState } from "react";
import { ErrorBoundary } from "react-error-boundary";
import toast from "react-hot-toast";
import AuthenticationWall from "~/components/authentication/wall";
import Toaster from "~/components/toaster";
import PageNotFound from "./404";
import InternalError from "./500";
import "core-js/actual";
import "~/theme/styles.css";
import { getAPI_ } from "~/api";
import { getCurrentUserStatus, getLibraries } from "@/api/queries";
import {
	DefaultQueryOptions,
	toTanStackInfiniteQuery,
	toTanStackQuery,
} from "@/api/query";
import { store } from "@/state/store";
import { accessTokenAtom } from "@/state/user";
import type { EmotionCache } from "@emotion/react";
import { AppCacheProvider } from "@mui/material-nextjs/v14-pagesRouter";
import { deepmerge } from "@mui/utils";
import { Provider } from "jotai";
import type { Page } from "ssr";
import { KeyboardBindingModal } from "~/components/keyboard-bindings-modal";
import Scaffold from "~/components/scaffold";
import { KeyboardBindingsProvider } from "~/contexts/keybindings";
import { withTranslations } from "~/i18n";
import ThemeProvider from "~/theme/provider";

export interface MyAppProps extends AppProps {
	emotionCache?: EmotionCache;
}

function MyApp({
	Component,
	pageProps: { session, lng, ...pageProps },
	emotionCache,
}: MyAppProps) {
	const [queryClient] = useState(
		() =>
			new QueryClient({
				defaultOptions: {
					queries: DefaultQueryOptions,
				},
			}),
	);
	const router = useRouter();
	const [errorType, setError] = useState<"not-found" | "error" | undefined>();
	useEffect(() => {
		setError(undefined);
	}, [router]);
	return (
		<AppCacheProvider emotionCache={emotionCache}>
			<ThemeProvider>
				<Head>
					{/* It is recommended to leave this here. The rest has been moved to `_document` */}
					<title>{AppName}</title>
					<meta
						name="viewport"
						content="initial-scale=1.0, width=device-width"
					/>
				</Head>
				<QueryClientProvider client={queryClient}>
					{/* 
						Recommended for SSR
						https://jotai.org/docs/guides/nextjs#provider
					*/}
					<Provider store={store}>
						<ConfirmProvider
							defaultOptions={{
								cancellationButtonProps: {
									sx: { marginX: 2 },
								},
							}}
						>
							<Hydrate state={pageProps.dehydratedState}>
								<AuthenticationWall>
									<ErrorBoundary
										FallbackComponent={() => {
											if (errorType === "not-found") {
												return <PageNotFound />;
											}
											return <InternalError />;
										}}
										onError={(error: Error) => {
											if (errorType) {
												toast.error(error.message);
											}
											if (
												error instanceof
												ResourceNotFound
											) {
												setError("not-found");
											} else {
												setError("error");
											}
										}}
									>
										<KeyboardBindingsProvider>
											<KeyboardBindingModal />
											<Scaffold>
												<Component {...pageProps} />
											</Scaffold>
										</KeyboardBindingsProvider>
									</ErrorBoundary>
								</AuthenticationWall>
							</Hydrate>
						</ConfirmProvider>
					</Provider>
					<Toaster />
					<ReactQueryDevtools
						buttonPosition="bottom-left"
						initialIsOpen={false}
					/>
				</QueryClientProvider>
			</ThemeProvider>
		</AppCacheProvider>
	);
}

MyApp.getInitialProps = async (appContext: AppContext) => {
	const { pageProps } = await NextApp.getInitialProps(appContext);
	const Component = appContext.Component as unknown as Page;

	const queryClient = new QueryClient({
		defaultOptions: {
			queries: DefaultQueryOptions,
		},
	});
	const accessToken: string | undefined = (appContext.ctx.req as any)
		?.cookies[UserAccessTokenStorageKey];

	if (!accessToken) {
		// Disable SSR if user is not authentified
		return { pageProps: {} };
	}
	const api = getAPI_(accessToken);
	store.set(accessTokenAtom, accessToken);
	const { queries, infiniteQueries, additionalProps } =
		(await Component.prepareSSR?.(appContext.ctx, queryClient)) ?? {};

	const userQueryResult = await queryClient
		.fetchQuery(toTanStackQuery(api, getCurrentUserStatus))
		.catch(() => null);
	if (userQueryResult != null) {
		try {
			await Promise.all([
				queryClient.prefetchInfiniteQuery(
					toTanStackInfiniteQuery(api, getLibraries),
				),
				...(infiniteQueries?.map((query) =>
					queryClient.prefetchInfiniteQuery(
						toTanStackInfiniteQuery(api, () => query),
					),
				) ?? []),
				...(queries?.map((query) =>
					queryClient.prefetchQuery(
						toTanStackQuery(api, () => query),
					),
				) ?? []),
			]);
		} catch {
			return {
				pageProps: {},
				notFound: true,
			};
		}
	}
	const dehydratedQueryClient = dehydrate(queryClient);

	return {
		pageProps: {
			props: deepmerge(pageProps, additionalProps),
			dehydratedState: dehydratedQueryClient,
		},
	};
};

export default withTranslations(MyApp);
